#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Jan 08, 2024 07:19:27 AM GMT  platform: Linux

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
import os
import hashlib
from pathlib import Path, PurePath
from datetime import datetime
import checksum

_debug = False  # False to eliminate debug printing from callback functions.
location = os.path.dirname(os.path.realpath(__file__))


def main(*args):
    """Main entry point for the application."""
    if _debug:
        print(main.__name__)
        print(f"\t{main.__doc__}")
        sys.stdout.flush()
        for index, arg in enumerate(args):
            print(f"\targ {index}:\n\t{arg}\n")
    global root, _top1, _w1
    root = tk.Tk()
    root.protocol("WM_DELETE_WINDOW", root.destroy)
    # Creates a toplevel widget.
    _top1 = root
    _w1 = checksum.Toplevel1(_top1)
    startup()
    root.mainloop()


def startup():
    """
    initialise the GUI and check for a working directory pointer
    hand off to path_build()
    """

    banner = """
    ============================================
    Running Checksum, file hash verification app
    ============================================
    """
    print(banner)
    if _debug:
        print("Debugging mode is enabled.\n")
    else:
        print("Debugging mode is disabled.\n")
    print("Dependencies...")
    print(sys.__name__)
    print(os.__name__)
    print(hashlib.__name__)
    print(datetime.__name__)
    print(Path.__name__)
    print(tk.__name__, "    v" + str(float(tk.TkVersion)))
    print(ttk.__name__, "v" + ttk.__version__)
    print()
    print("GUI designed using the PAGE framework, version 8.0")
    print("https://sourceforge.net/projects/page/")
    print()
    if _debug:
        print(startup.__name__)
        print(f"\t{startup.__doc__}")
        print()
    global root_file_path
    _w1.dir_selector.bind("<<ComboboxSelected>>", lambda e: on_DirSelect(e))
    _w1.file_selector.bind("<<ComboboxSelected>>", lambda e: on_FileSelect(e))
    _w1.SaveBtn.configure(state="disabled")
    _w1.VerifyBtn.configure(state="disabled")
    _w1.status_txt.set("Waiting...")
    _w1.file_attributes.set("Date:          \tSize:")
    root_dir = PurePath(Path(location).joinpath(Path("root_dir")))
    root_file_path = False
    if os.path.isfile(
        root_dir
    ):  # if it exists, this file points to the default working directory
        with open(file=root_dir, mode="r", encoding="UTF-8") as root_path:
            root_file_path = root_path.readline()
    if root_file_path and os.path.exists(root_file_path):
        path_build(root_file_path)
    else:
        path_build(location)
        root_file_path = False


def path_build(src):
    """
    create the file tree directory navigation object from src and populate
    the dir_selector TCombobox dir_selector widget
    filter out directory names that start with a period or a dunder
    call to file_selector_update()
    return two list objects:
        directories list
        files list
    """
    if _debug:
        print(path_build.__name__)
        print(f"\t{path_build.__doc__}")
        print(f"src:{src}")
        print()
    parent = os.path.abspath(os.path.join(src, os.pardir))
    if os.path.exists(src):
        path, dirs, files = next(os.walk(src))
        dirs_lst = [parent, path]
    else:
        path, dirs, files = next(os.walk(parent))
        dirs_lst = [parent]
    for dir_name in dirs:
        pp = PurePath(Path(path).joinpath(Path(dir_name)))
        if dir_name.startswith(".") or dir_name.startswith("__"):
            pass
        else:
            dirs_lst.append(f"{str(pp)}")
    dirs_lst.sort()
    _w1.dir_selector["values"] = dirs_lst
    _w1.dir_selector.set(dirs_lst[1])
    file_selector_update(files)
    return dirs_lst, files


def file_selector_update(files):
    """
    update the TCombobox file_selector with the list of file names
    filter out file names that start with a period
    """
    if _debug:
        print(file_selector_update.__name__)
        print(f"\t{file_selector_update.__doc__}")
        print("files:")
        for file in files:
            print(f"\t{file}")
        print()
    files_lst = []
    for file_name in files:
        if file_name.startswith("."):
            pass
        else:
            files_lst.append(file_name)
    files_lst.sort()
    _w1.file_selector["values"] = files_lst


def on_DirSelect(e):
    """
    call gui_reset()
    create a files list object by reading the TCombobox dir_selector and passing
    that value to path_build()
    filter out any file names that start with a period
    sort the file name names in ascending order and assign the list of files
    to the file_selector TCombobox widget
    """
    if _debug:
        print(on_DirSelect.__name__)
        print(f"\t{on_DirSelect.__doc__}")
        print(f"arg:{e}")
        print()
    files_lst = []
    gui_reset()
    if _w1.file_selector.get():
        _w1.file_selector.delete(0, END)
        _w1.file_attributes.set("Date:          \tSize:")

    selected = _w1.dir_selector.get()
    dirs_lst, files = path_build(selected)
    for file_name in files:
        if file_name.startswith("."):
            pass
        else:
            files_lst.append(file_name)
    files_lst.sort()
    _w1.file_selector["values"] = files_lst


def on_FileSelect(e):
    """
    call gui_reset()
    read the dir_selector value to build a file_path object
    call os.stat() and get .st_size and .st_ctime
    update the GUI
    hand off to hash_gen() with the file_path object
    """
    if _debug:
        print(on_FileSelect.__name__)
        print(f"\t{on_FileSelect.__doc__}")
        print(f"arg:{e}")
        print()
    gui_reset()
    output = "Date: "
    dir_sel = _w1.dir_selector.get()
    selected = _w1.file_selector.get()
    file_path = PurePath(Path(dir_sel).joinpath(Path(selected)))
    stats = os.stat(file_path)
    byts = stats.st_size
    date, time = str(datetime.fromtimestamp(stats.st_ctime)).split(" ")
    y, m, d = date.split("-")
    output += f"{d}-{m}-{y}\t"
    kb = byts / 1000
    mb = kb / 1000
    gb = mb / 1000
    if int(gb) > 0:
        output += f"Size: {gb:0.2f} GB"
    elif int(mb) > 0:
        output += f"Size: {mb:0.2f} MB"
    elif int(kb) > 0:
        output += f"Size: {kb:0.2f} kB"
    else:
        output += f"Size: {byts} bytes"
    _w1.file_attributes.set(output)
    hash_gen(file_path)


def gui_reset():
    """
    clear the gui of any previous values
    """
    if _debug:
        print(gui_reset.__name__)
        print(f"\t{gui_reset.__doc__}")
        print()
    lbl_objects = [_w1.MD5_Lbl, _w1.SHA1_Lbl, _w1.SHA256_Lbl, _w1.SHA512_Lbl]
    dgst_objects = [_w1.md5h_Dgst, _w1.sha1h_Dgst, _w1.sha256h_Dgst, _w1.sha512h_Dgst]
    txt_objects = [_w1.MD5_Txt, _w1.SHA1_Txt, _w1.SHA256_Txt, _w1.SHA512_Txt]
    for index in range(4):
        lbl_objects[index].configure(foreground="black")
        dgst_objects[index].set("")
        txt_objects[index].delete("1.0", END)
    _w1.status_txt.set("Waiting...")
    _w1.SaveBtn.configure(state="disabled")
    _w1.VerifyBtn.configure(state="disabled")


def hash_gen(file_path):
    """
    generate the file hash digest and update all four hash value objects, in parallel
    activate the verify hash values and save hash values buttons
    update the status message
    generate a report and make it 'global' for the save hash values option
    """
    if _debug:
        print(hash_gen.__name__)
        print(f"\t{hash_gen.__doc__}")
        if file_path:
            pass
        else:
            print("warning: no file path data")
        print()
    global report
    if file_path:
        md5 = hashlib.md5()
        sha1 = hashlib.sha1()
        sha256 = hashlib.sha256()
        sha512 = hashlib.sha512()
        with open(file_path, "rb") as file:
            # loop till the end of the file
            rBytes = 0
            while rBytes != b"":
                # read 1024 bytes at a time
                rBytes = file.read(1024)
                md5.update(rBytes)
                sha1.update(rBytes)
                sha256.update(rBytes)
                sha512.update(rBytes)
        md5_hd = md5.hexdigest()
        sha1_hd = sha1.hexdigest()
        sha256_hd = sha256.hexdigest()
        sha512_hd = sha512.hexdigest()
    _w1.md5h_Dgst.set(md5_hd)
    _w1.sha1h_Dgst.set(sha1_hd)
    _w1.sha256h_Dgst.set(sha256_hd)
    _w1.sha512h_Dgst.set(sha512_hd)
    _w1.SaveBtn.configure(state="normal")
    _w1.VerifyBtn.configure(state="normal")
    _w1.status_txt.set("Hash values unsaved.")
    report = "#====<GENERATED BY FILE CHECKSUM V2>====#\n\n"
    report += f"Hash values for {str(file_path)}\n\n"
    report += f"MD5\n{md5_hd}\n\n"
    report += f"SHA-1\n{sha1_hd}\n\n"
    report += f"SHA-256\n{sha256_hd}\n\n"
    report += f"SHA-512\n{sha512_hd}"
    if _debug:
        print(report)
        print()


def on_path_save():
    """
    change the button text of the 'Exit' button based upon
    the path_save switch condition
    """
    if _debug:
        print(on_path_save.__name__)
        print(f"\t{on_path_save.__doc__}")
        print()
    if _w1.path_save.get():
        _w1.QuitBtn.configure(text="""Save & Exit""")
    else:
        _w1.QuitBtn.configure(text="""Exit""")


def on_quit():
    """
    read the path_save condition and perform a clean exit call to sys.exist()
    if the path_save condition is True, compare the root_file_path with path.get()
    and only write the root_dir file if the compare is False
    """
    if _debug:
        print(on_quit.__name__)
        print(f"\t{on_quit.__doc__}")
        print()
    if _w1.path_save.get():
        if root_file_path == _w1.path.get():
            pass
        else:
            root_dir = PurePath(Path(location).joinpath(Path("root_dir")))
            with open(file=root_dir, mode="w", encoding="UTF-8") as output:
                print(_w1.path.get().strip(), end="", file=output)
    sys.exit("File checksum: clean exit")


def on_verify():
    """
    compare the dgst_objects to the txt_objects and update the lbl_objects
    based upon the outcome:
        green for a match
        red   for a mismatch
        grey  for an unknown
    """
    if _debug:
        print(on_verify.__name__)
        print(f"\t{on_verify.__doc__}")
        print()
    txt_objects = [_w1.MD5_Txt, _w1.SHA1_Txt, _w1.SHA256_Txt, _w1.SHA512_Txt]
    lbl_objects = [_w1.MD5_Lbl, _w1.SHA1_Lbl, _w1.SHA256_Lbl, _w1.SHA512_Lbl]
    dgst_objects = [_w1.md5h_Dgst, _w1.sha1h_Dgst, _w1.sha256h_Dgst, _w1.sha512h_Dgst]

    for index in range(4):
        if txt_objects[index].get("1.0", END).strip():
            if dgst_objects[index].get() == txt_objects[index].get("1.0", END).strip():
                lbl_objects[index].configure(foreground="green")
            else:
                lbl_objects[index].configure(foreground="red")
        else:
            lbl_objects[index].configure(foreground="grey")


def on_save():
    """
    get the current file path from path.get()
    append '/hash_values.txt' to the file path
    open a new file and write the hash values report
    update the status message
    disable the Save Hash Values button
    """
    if _debug:
        print(on_save.__name__)
        print(f"\t{on_save.__doc__}")
        print()
    with open(
        file=f"{_w1.path.get()}/hash_values.txt", mode="w", encoding="UTF-8"
    ) as output:
        print(report, file=output)
    _w1.status_txt.set(f"Hash values saved to {_w1.path.get()}")
    _w1.SaveBtn.configure(state="disabled")


if __name__ == "__main__":
    checksum.start_up()
